## 浮点数的二进制表示
### 一. 10进制数的科学计数法
```text
任何十进制数都可以表示成科学计数法的形式，即m*10^n, 1<= m <10, n为正整数
例如：
1346  = 1.346 * 10^3
134.6 = 1.346 * 10^2
```
### 二. 浮点数的二进制表示
```text
小数位乘以2，取个位当二进制位，然后小数位再乘以2，往复下去，一直到成积为0为止
例如：对于小数0.6
0.6*2=1.2 ==> 取1
0.2*2=0.4 ==> 取0
0.4*2=0.8 ==> 取0
0.8*2=1.8 ==> 取1
······
0.6的二进制位是1001 1001 ···， 后面都是1001的循环，所以0.6是不能被二进制精确表示的。
0.6 = 1* 2^-1 + 0* 2^-2 + 0* 2^-3 + 1* 2^-4 + ··· = 1/2 + 0 + 0 + 1/16 + ···
从这里可以看出，1/2, 1/4, 1/8, 1/16,···的和是不可能表示所有的小数,这就是浮点数丢失精度的真正原因。
```
### 二. 浮点数的二进制科学计数法
```text
类比10进制的科学计数法 1.7 1.4 0.8 1.6
对于一个浮点数17.85,转换成2进制为: 00010001.1101 1101 1101 1101 1101 1101,小数点后面是1101循环。
类似的二进制的科学计数法公式：m * 2^n
所以，00010001.1101 1101 1101 1101 1101 1101 = 1.0001 1101 1101 1101 1101 1101 1101 * 2^4
由此可知，m=1.0001 1101 1101 1101 1101 1101 1101, n=4, m就是有效的数字，保留了最原始的信息。
对于二进制的科学计数法，小数点前永远是1，所以为了节省空间，只取小数点后面的作为有效的数字(即0001 1101 1101 1101 1101 1101 1101)
java的浮点数占4个字节，32个bit位，从左往右数，左边的第一个bit为第31位，所以浮点数的存储规则：
1.第31位：存0或者1，代表了浮点数的正负，0=正数，1=负数
2。第30位到第22位：共8个bit位，储存了公式中n的值，在上面的例子中，n=4（0100）
3. 第21到第0位：共22位，存储有效数字，即公式中的m（0001 1101 1101 1101 1101 1101 1101），超出的位数将被忽略
那么根据上述的规则，则17。85的二进制为：
0 00000100 0001110111011101110111
且慢，实际上是这样吗？其实还有一点差别，主要是针对规则2第30位到第22位，我们知道这8位存储的是指数n的值，实际上，这个n是
可以为负数的，但是第30位到第22位所表示的又是一个无符号的正数，所以


```

http://c.biancheng.net/view/314.html
https://blog.csdn.net/chencheng19912012/article/details/30072389
https://tooltt.com/floatconverter/