## 浮点数的二进制表示
### 一. 10进制数的科学计数法
```text
任何十进制数都可以表示成科学计数法的形式，即m*10^n, 1<= m <10, n为正整数
例如：
1346  = 1.346 * 10^3
134.6 = 1.346 * 10^2
```
### 二. 浮点数的二进制表示
```text
小数位乘以2，取个位当二进制位，然后小数位再乘以2，往复下去，一直到成积为0为止
例如：对于小数0.6
0.6*2=1.2 ==> 取1
0.2*2=0.4 ==> 取0
0.4*2=0.8 ==> 取0
0.8*2=1.8 ==> 取1
······
0.6的二进制位是1001 1001 ···， 后面都是1001的循环，所以0.6是不能被二进制精确表示的。
0.6 = 1* 2^-1 + 0* 2^-2 + 0* 2^-3 + 1* 2^-4 + ··· = 1/2 + 0 + 0 + 1/16 + ···
从这里可以看出，1/2, 1/4, 1/8, 1/16,···的和是不可能表示所有的小数,这就是浮点数丢失精度的真正原因。
```
### 二. 浮点数的二进制科学计数法
```text
类比10进制的科学计数法 
对于一个浮点数17.85,转换成2进制为: 00010001.1101 1001 1001 1001 1001 1001 1001,后面是0110循环。
类似的，假如二进制的科学计数法公式：m * 2^n
所以，00010001.1101 1001 1001 1001 1001 1001 1001 = 1.0001 1101 1001 1001 1001 1001 1001 1001 * 2^4
由此可知，m=1.0001 1101 1001 1001 1001 1001 1001 1001, n=4, m就是有效的数字，保留了最原始的信息。
对于二进制的科学计数法，小数点前永远是1，所以为了节省空间，只取小数点后面的作为有效的数字(即0001 1101 1001 1001 1001 1001 1001 1001)
java的浮点数占4个字节，32个bit位，从左往右数，左边的第一个bit为第31位，所以浮点数的存储规则：
1.第31位：存0或者1，代表了浮点数的正负，0=正数，1=负数
2。第30位到第23位：共8个bit位，储存了公式中n的值，在上面的例子中，n=4（0100）
3. 第22到第0位：共23位，存储有效数字，即公式中的m（0001 1101 1001 1001 1001 1001 1001 1001），超出的位数右边将被忽略
那么根据上述的规则，则17.85的二进制为：
0 00000100 0001 1101 1001 1001 1001 101
且慢，实际上是这样吗？其实还有一点差别，主要是针对规则2第30位到第23位，我们知道这8位存储的是指数n的值，实际上，这个n是
可以为负数的，但是第30位到第22位所表示的又是一个无符号的正数（0～255）， 所以用127～255表示的是正数， 1～126表示负数，我们这里的n=4
第30位到第22位存储的就不是4(00000100),而是4+127=131（10000011），所以对于浮点数17.85的二进制是：
0 10000011 00011101110111011101110
等等，还有其他问题嘛，还是有的，就是有效数字m的舍入规则，它不是简单的舍入，实际上时按照一下规则：

浮点数的舍入
任何有效数上的运算结果，通常都存放在较长的寄存器中，当结果被放回浮点格式时，必须将多出来的比特丢弃。 有多种方法可以用来运行舍入作业，实际上IEEE标准列出4种不同的方法：
舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中式以0结尾的）。
朝+∞方向舍入：会将结果朝正无限大的方向舍入。
朝-∞方向舍入：会将结果朝负无限大的方向舍入。
朝0方向舍入：会将结果朝0的方向舍入。
上面的浮点数的二进制算术标准是1985年提出IEEE754。
```
### 三. java中的float
由于java中float和int类型的所占用的空间是一样的，都是4个byte
### 四. 附录

- [一个浮点数转换的小工具](https://tooltt.com/floatconverter/)

